# DO NOT EDIT THIS FILE
import unittest
import json
from time import clock
import os
import requests
from q1 import question01
from q2 import question02
from q3 import question03
from q4 import question04
from q5 import question05
from q6 import question06


class Test(unittest.TestCase):

    def runq1_main():
        travis_uuid = os.getenv('travis_uuid', '')
        tests = requests.get(
            'https://cscc-gl.herokuapp.com/tests/run/1/' + travis_uuid).content
        response = []
        for testnumber in range(0, len(tests)):
            try:
                return_dict = Manager().dict()
                test = tests[testnumber]
                q1input = test["input"]
                p = Process(target=runq1, args=(q1input, return_dict))
                p.start()

                # Wait for 1 seconds or until process finishes
                p.join(1)

                # If thread is still active
                if p.is_alive():
                    # Terminate
                    print(
                        "A question 1 test has timed out. Each individual test has a maximum of one second to run.")
                    p.terminate()
                    p.join()
                else:
                    correct = return_dict['output'] == test["output"]
                    response.append({
                        "questionNumber": 1,
                        "testNumber": testnumber,
                        "correct": correct,
                        "speed": return_dict['diff'] * 1000000000
                    })
            except Exception as e:
                print(e)
        if travis_uuid != '':
            requests.post('https://cscc-gl.herokuapp.com/answer/contestant/' + travis_uuid + '/1', data=jsonify(response))


    def runq2_main():
        travis_uuid = os.getenv('travis_uuid', '')
        tests = requests.get(
            'https://cscc-gl.herokuapp.com/tests/run/2/' + travis_uuid).content
        response = []
        for testnumber in range(0, len(tests)):
            try:
                return_dict = Manager().dict()
                test = tests[testnumber]
                q2input = test["input"]
                p = Process(target=runq2, args=(q2input, return_dict))
                p.start()

                # Wait for 1 seconds or until process finishes
                p.join(1)

                # If thread is still active
                if p.is_alive():
                    # Terminate
                    print(
                        "A question 2 test has timed out. Each individual test has a maximum of one second to run.")
                    p.terminate()
                    p.join()
                else:
                    correct = return_dict['output'] == test["output"]
                    response.append({
                        "questionNumber": 2,
                        "testNumber": testnumber,
                        "correct": correct,
                        "speed": return_dict['diff'] * 1000000000
                    })
            except Exception as e:
                print(e)
        if travis_uuid != '':
            requests.post('https://cscc-gl.herokuapp.com/answer/contestant/' + travis_uuid + '/2', data=jsonify(response))


    def runq3_main():
        travis_uuid = os.getenv('travis_uuid', '')
        tests = requests.get(
            'https://cscc-gl.herokuapp.com/tests/run/3/' + travis_uuid).content
        response = []
        for testnumber in range(0, len(tests)):
            try:
                return_dict = Manager().dict()
                test = tests[testnumber]
                q3input = test["input"]
                p = Process(target=runq3, args=(q3input, return_dict))
                p.start()

                # Wait for 1 seconds or until process finishes
                p.join(1)

                # If thread is still active
                if p.is_alive():
                    # Terminate
                    print(
                        "A question 3 test has timed out. Each individual test has a maximum of one second to run.")
                    p.terminate()
                    p.join()
                else:
                    correct = return_dict['output'] == test["output"]
                    response.append({
                        "questionNumber": 3,
                        "testNumber": testnumber,
                        "correct": correct,
                        "speed": return_dict['diff'] * 1000000000
                    })
            except Exception as e:
                print(e)
        if travis_uuid != '':
            requests.post('https://cscc-gl.herokuapp.com/answer/contestant/' + travis_uuid + '/3', data=jsonify(response))

    
    def runq4_main():
        travis_uuid = os.getenv('travis_uuid', '')
        tests = requests.get(
            'https://cscc-gl.herokuapp.com/tests/run/4/' + travis_uuid).content
        response = []
        for testnumber in range(0, len(tests)):
            try:
                return_dict = Manager().dict()
                test = tests[testnumber]
                q4input = test["input"]
                p = Process(target=runq4, args=(q4input, return_dict))
                p.start()

                # Wait for 1 seconds or until process finishes
                p.join(1)

                # If thread is still active
                if p.is_alive():
                    # Terminate
                    print(
                        "A question 4 test has timed out. Each individual test has a maximum of one second to run.")
                    p.terminate()
                    p.join()
                else:
                    correct = return_dict['output'] == test["output"]
                    response.append({
                        "questionNumber": 4,
                        "testNumber": testnumber,
                        "correct": correct,
                        "speed": return_dict['diff'] * 1000000000
                    })
            except Exception as e:
                print(e)
        if travis_uuid != '':
            requests.post('https://cscc-gl.herokuapp.com/answer/contestant/' + travis_uuid + '/4', data=jsonify(response))


    def runq5_main():
        travis_uuid = os.getenv('travis_uuid', '')
        tests = requests.get(
            'https://cscc-gl.herokuapp.com/tests/run/5/' + travis_uuid).content
        response = []
        for testnumber in range(0, len(tests)):
            try:
                return_dict = Manager().dict()
                test = tests[testnumber]
                q6input = test["input"]
                p = Process(target=runq5, args=(q6input, return_dict))
                p.start()

                # Wait for 1 seconds or until process finishes
                p.join(1)

                # If thread is still active
                if p.is_alive():
                    # Terminate
                    print(
                        "A question 5 test has timed out. Each individual test has a maximum of one second to run.")
                    p.terminate()
                    p.join()
                else:
                    correct = return_dict['output'] == test["output"]
                    response.append({
                        "questionNumber": 5,
                        "testNumber": testnumber,
                        "correct": correct,
                        "speed": return_dict['diff'] * 1000000000
                    })
            except Exception as e:
                print(e)
        if travis_uuid != '':
            requests.post('https://cscc-gl.herokuapp.com/answer/contestant/' + travis_uuid + '/5', data=jsonify(response))


    def runq6_main():
        travis_uuid = os.getenv('travis_uuid', '')
        tests = requests.get(
            'https://cscc-gl.herokuapp.com/tests/run/6/' + travis_uuid).content
        response = []
        for testnumber in range(0, len(tests)):
            try:
                return_dict = Manager().dict()
                test = tests[testnumber]
                q6input = test["input"]
                p = Process(target=runq6, args=(q6input, return_dict))
                p.start()

                # Wait for 1 seconds or until process finishes
                p.join(1)

                # If thread is still active
                if p.is_alive():
                    # Terminate
                    print(
                        "A question 6 test has timed out. Each individual test has a maximum of one second to run.")
                    p.terminate()
                    p.join()
                else:
                    correct = return_dict['output'] == test["output"]
                    response.append({
                        "questionNumber": 6,
                        "testNumber": testnumber,
                        "correct": correct,
                        "speed": return_dict['diff'] * 1000000000
                    })
            except Exception as e:
                print(e)
        if travis_uuid != '':
            requests.post('https://cscc-gl.herokuapp.com/answer/contestant/' + travis_uuid + '/6', data=jsonify(response))

# DO NOT CHANGE THIS FUNCTION EITHER
def runq1(q1input, return_dict):
    start = clock()
    i = json.loads(q1input)
    output = question01(i.initialLevelOfDebt, i.interestPercentage, i.repaymentPercentage)
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff

# DO NOT CHANGE THIS FUNCTION EITHER
def runq2(q2input, return_dict):
    start = clock()
    i = json.loads(q2input)
    output = question02(i.risk, i.bonus, i.trader)
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff

# DO NOT CHANGE THIS FUNCTION EITHER
def runq3(q3input, return_dict):
    start = clock()
    i = json.loads(q3input)
    output = question03(i.scores, i.alice)
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff

# DO NOT CHANGE THIS FUNCTION EITHER
def runq4(q4input, return_dict):
    start = clock()
    i = json.loads(q4input)
    output = question04(i.v, i.c, i.mc)
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff

# DO NOT CHANGE THIS FUNCTION EITHER
def runq5(q5input, return_dict):
    start = clock()
    i = json.loads(q5input)
    output = question05(i)
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff

# DO NOT CHANGE THIS FUNCTION EITHER
def runq6(q6input, return_dict):
    start = clock()
    i = json.loads(q6input)
    output = question06(i)
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff

if __name__ == '__main__':
    unittest.main()
